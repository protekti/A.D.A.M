def drawLines(image):
    cdstP = np.copy(image)
    blur = cv2.GaussianBlur(cdstP,(15,15),0)
    gray = cv2.cvtColor(blur, cv2.COLOR_BGR2GRAY)
    
    linesP = cv2.HoughLinesP(gray, 1, np.pi / 180, 50, None, 50, 10)
    if linesP is not None:
        # Initialize lists to store left and right lane lines
        left_lines = []
        right_lines = []
        
        # Separate lines into left and right lanes based on the slope
        for line in linesP:
            x1, y1, x2, y2 = line[0]
            slope = (y2 - y1) / float(x2 - x1) if (x2 - x1) != 0 else 0
            
            # Classify lines as left or right based on the slope and x-position
            if slope < 0:  # Negative slope -> Left lane
                left_lines.append((x1, y1, x2, y2))
            elif slope > 0:  # Positive slope -> Right lane
                right_lines.append((x1, y1, x2, y2))

        # Average the left and right lines if available
        def average_lines(lines):
            if len(lines) == 0:
                return None
            # Average x and y coordinates of the lines
            avg_x1 = np.mean([line[0] for line in lines])
            avg_y1 = np.mean([line[1] for line in lines])
            avg_x2 = np.mean([line[2] for line in lines])
            avg_y2 = np.mean([line[3] for line in lines])
            return (int(avg_x1), int(avg_y1), int(avg_x2), int(avg_y2))

        # Calculate the average left and right lane lines
        left_avg = average_lines(left_lines)
        right_avg = average_lines(right_lines)

        # Draw the averaged left and right lane lines
        if left_avg is not None:
            cv2.line(cdstP, (left_avg[0], left_avg[1]), (left_avg[2], left_avg[3]), (0, 0, 255), 3, cv2.LINE_AA)
        if right_avg is not None:
            cv2.line(cdstP, (right_avg[0], right_avg[1]), (right_avg[2], right_avg[3]), (0, 0, 255), 3, cv2.LINE_AA)
    
    return cdstP
